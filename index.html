<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
  <title>Tommy Green's Audiolooper</title>
  <style>
    :root{
      --bg:#0b0f14; --panel:#111827; --panel-2:#0f172a; --text:#e5e7eb; --text-dim:#9ca3af;
      --line:#1f2937; --accent:#60a5fa; --danger:#ef4444; --ok:#16a34a; --muted:#334155;
    }
    *{ box-sizing:border-box; }
    html,body{ height:100%; background:var(--bg); color:var(--text); }
    body{ margin:0; padding:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }

    /* ---------- Buch-/Flip-Layout ---------- */
    .scene{ position:relative; width:100%; min-height:100vh; perspective: 1800px; overflow:hidden; transform-style:preserve-3d; }
    .book{ position:relative; width:100%; min-height:100vh; transform-style: preserve-3d; transition: transform .9s cubic-bezier(.22,.61,.36,1); }
    .book.flipped{ transform:none; }
    .page{ position:absolute; inset:0; backface-visibility:hidden; overflow:auto; padding:20px; will-change: transform; transform-style:preserve-3d; transform-origin:50% 50%; transition: transform .9s cubic-bezier(.22,.61,.36,1); }
    .page.left{ transform: rotateY(0deg) translateZ(0); z-index:2; }
    .page.right{ transform: rotateY(-180deg) translateZ(0); z-index:1; }
    .book.flipped .page.left{ transform: rotateY(180deg) translateZ(0); z-index:1; }
    .book.flipped .page.right{ transform: rotateY(0deg) translateZ(0); z-index:2; }
    .book::before{
      content:""; position:absolute; inset:0; pointer-events:none;
      background: radial-gradient(1200px 200px at 50% 50%, rgba(255,255,255,.06), transparent 60%);
      mix-blend-mode: screen; opacity:.35; transition: opacity .3s ease;
    }
    .book.flipped::before{ opacity:.25; }

    /* ---------- Floating Flip-Pfeile ---------- */
    .flip-arrow{
      position:fixed; top:50%; transform: translateY(-50%);
      z-index:9999; width:48px; height:48px; display:flex; align-items:center; justify-content:center;
      border:1px solid rgba(96,165,250,.35); border-radius:999px;
      background: linear-gradient(180deg,#0b1220,#09101c);
      box-shadow: 0 8px 30px rgba(0,0,0,.45), 0 0 0 5px rgba(59,130,246,.08);
      cursor:pointer; transition: transform .15s ease, box-shadow .2s ease, border-color .2s ease, opacity .2s ease; user-select:none;
    }
    .flip-arrow:hover{ border-color:#3b82f6; box-shadow: 0 10px 36px rgba(0,0,0,.55), 0 0 0 6px rgba(59,130,246,.14); transform: translateY(-50%) scale(1.05); }
    .flip-arrow:active{ transform: translateY(-50%) scale(.98); }
    .flip-arrow.right{ right:14px; }
    .flip-arrow.left{ left:14px; display:none; }
    .flip-arrow svg{ width:26px; height:26px; }

    /* ---------- UI ---------- */
    h1{ margin:0 0 16px; font-size:22px; font-weight:800; letter-spacing:.2px; color:#f8fafc; text-align:center; }
    .card{ border:1px solid var(--line); background:linear-gradient(180deg,var(--panel),var(--panel-2)); border-radius:16px; padding:16px; box-shadow:0 4px 24px rgba(0,0,0,.35); }
    .grid-2{ display:grid; grid-template-columns:1fr 1fr; gap:10px; }
    .stack{ display:grid; gap:14px; }
    .section-gap{ height:28px; }
    .v-gap{ height:18px; }

    .btn{
      appearance:none; cursor:pointer; border:1px solid var(--muted);
      background:#0b1220; color:var(--text); border-radius:12px; padding:12px 14px;
      font-weight:700; letter-spacing:.2px; transition:.15s; display:inline-flex; align-items:center; justify-content:center; gap:8px;
    }
    .btn:hover{ border-color:#3b82f6; box-shadow:0 0 0 2px rgba(59,130,246,.15) inset; }
    .btn.primary{ background:linear-gradient(180deg,#1e293b,#0b1220); border-color:#3b82f6; color:#dbeafe; }
    .btn.ok{ border-color:#15803d; color:#dcfce7; }
    .btn.warn{ border-color:#b91c1c; color:#fee2e2; }
    .btn.big{ padding:18px 20px; font-size:18px; border-radius:14px; background:linear-gradient(180deg,#0b1220,#09101c); }
    .btn:active{ transform:translateY(1px); }

    /* File-Inputs: visuell versteckt (NICHT display:none) */
    .file{
      position:absolute; width:1px; height:1px; padding:0; margin:-1px;
      overflow:hidden; clip:rect(0,0,0,0); clip-path: inset(50%);
      white-space:nowrap; border:0;
    }

    .label{ font-size:12px; color:var(--text-dim); margin-bottom:6px; }
    .field{ background:#0b1220; border:1px solid var(--muted); color:#e5e7eb; border-radius:12px; padding:10px 12px; width:100%; font-weight:600; }
    .mono{ font-variant-numeric: tabular-nums; font-family: ui-monospace,SFMono-Regular,Menlo,monospace; }
    .filename-chip{ display:flex; align-items:center; gap:8px; border:1px solid var(--muted); background:rgba(99,102,241,.06); border-radius:12px; padding:10px 12px; min-height:44px; color:#c7d2fe; }
    .filename-chip .dot{ width:8px; height:8px; border-radius:999px; background:#c084fc; box-shadow:0 0 8px #c084fc; }

    #wave{ width:100%; height:240px; display:block; background:linear-gradient(180deg,#0c1423,#0a1320); border:1px solid var(--muted); border-radius:14px; touch-action:none; }
    .under-time{ margin-top:8px; text-align:center; font-size:13px; color:#cbd5e1; background:#0b1220; border:1px solid var(--muted); border-radius:10px; padding:8px 10px; display:inline-block; }

    .markerList{ display:grid; gap:10px; }
    .markerRow{ display:grid; grid-template-columns:28px 1fr auto auto; gap:10px; align-items:center; border:1px solid var(--muted); background:#0b1220; border-radius:12px; padding:8px; }
    .dragHandle{ width:24px; height:24px; display:flex; align-items:center; justify-content:center; cursor:grab; user-select:none; touch-action: none; }
    .markerRow.dragging{ opacity:.6; }
    .markerRow.drop-before{ box-shadow:0 -2px 0 0 var(--accent) inset; }
    .markerRow.drop-after{  box-shadow:0  2px 0 0 var(--accent) inset; }

    .markerRow{ position:relative; transition: transform .15s ease, box-shadow .15s ease, background .15s ease; }
    .dragHandle:active{ cursor:grabbing; }
    .markerRow.dragging{ opacity:1; transform: translateY(-1px) scale(1.015); box-shadow: 0 12px 30px rgba(0,0,0,.55), 0 0 0 2px rgba(96,165,250,.18) inset; z-index: 2; }
    .markerRow.drop-target{ transform: translateY(0) scale(1.01); box-shadow: 0 8px 24px rgba(0,0,0,.35); }
    .markerRow.drop-before::before,
    .markerRow.drop-after::after{
      content:""; position:absolute; left:8px; right:8px; height:4px; border-radius:999px;
      background: linear-gradient(90deg, rgba(59,130,246,0), rgba(59,130,246,.9), rgba(59,130,246,0));
      box-shadow: 0 0 12px rgba(59,130,246,.45); pointer-events:none;
    }
    .markerRow.drop-before::before{ top:-2px; }
    .markerRow.drop-after::after{ bottom:-2px; }

    .icon{ display:inline-block; line-height:0; }
    .icon svg{ width:20px; height:20px; }
    .icon.play svg{ width:28px; height:28px; }
    .icon.stop svg{ width:26px; height:26px; }

    .page::-webkit-scrollbar{ width:10px; }
    .page::-webkit-scrollbar-thumb{ background:#1f2937; border-radius:999px; }
    .page::-webkit-scrollbar-track{ background:transparent; }

    /* ---------- Rechter Texteditor ---------- */
    .note-wrap{ max-width: 900px; margin:0 auto; display:grid; gap:14px; }
    .note-stats{ color:#cbd5e1; font-size:13px; text-align:center; }
    .lyricsList{ display:grid; gap:10px; }
    .lyricsRow{
      display:grid; grid-template-columns: 48px 1fr; gap:10px; align-items:center;
      border:1px solid var(--muted); background:#0b1220; border-radius:12px; padding:10px;
      transition: border-color .15s ease, box-shadow .15s ease, background .15s ease;
    }
    .lyricsRow .idx{
      width:40px; height:40px; border-radius:10px; display:flex; align-items:center; justify-content:center;
      background:#0c1423; border:1px solid var(--line); color:#93c5fd; font-weight:800; user-select:none;
    }
    .lyricsRow .line{ min-height:40px; outline:none; white-space:pre-wrap; word-break:break-word; }
    .lyricsRow.active{ border-color:#60a5fa; box-shadow:0 0 0 3px rgba(59,130,246,.15) inset; background:linear-gradient(180deg,#0b1220,#0a1320); }
    .note-hint{ color:#94a3b8; font-size:12px; text-align:center; }

    .note-tools{ display:flex; gap:10px; justify-content:center; flex-wrap:wrap; }
    .btn.toggle.active{ border-color:#3b82f6; box-shadow:0 0 0 2px rgba(59,130,246,.2) inset; }
    .segmentHeader{
      grid-column:1 / -1; margin:18px 0 6px 0; padding:10px 12px; border:1px dashed var(--line);
      background:#0c1423; color:#93c5fd; border-radius:12px; font-weight:800; text-transform:uppercase; letter-spacing:.4px; opacity:.9;
    }

    .note-export{ display:flex; justify-content:flex-end; margin-top:10px; }

    /* Quick-Loop aktivierte Zeilennummern */
    .lyricsRow .idx.ql-active{ border-color: var(--danger); color: #fecaca; background: #1a0f12; box-shadow: 0 0 0 3px rgba(239,68,68,.18) inset; }

    /* Hinweisleiste */
    .notice{
      display:flex; align-items:center; gap:10px; padding:10px 12px;
      border:1px solid #1e3a8a; background:rgba(30,58,138,.2); color:#bfdbfe;
      border-radius:12px; font-weight:700;
    }
    .notice .btn{ padding:8px 10px; font-size:14px; }
    .notice[hidden]{ display:none; }
  </style>
</head>
<body>
  <!-- Floating Flip-Pfeile -->
  <button id="toRight" class="flip-arrow right" aria-label="Zur rechten Seite wechseln" title="Zur rechten Seite wechseln">
    <svg viewBox="0 0 24 24" fill="none" aria-hidden="true"><path d="M9 5l7 7-7 7" stroke="#93c5fd" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
  </button>
  <button id="toLeft" class="flip-arrow left" aria-label="Zur linken Seite wechseln" title="Zur linken Seite wechseln">
    <svg viewBox="0 0 24 24" fill="none" aria-hidden="true"><path d="M15 5l-7 7 7 7" stroke="#93c5fd" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
  </button>

  <div class="scene">
    <div id="book" class="book">
      <!-- Linke Seite (bestehende App) -->
      <section class="page left">
        <h1>Tommy's Audiolooper</h1>

        <div class="card stack">
          <!-- Notice -->
          <div id="notice" class="notice" hidden>
            <span id="noticeText">Hinweis</span>
            <button id="noticeBtn" class="btn">Audio wählen</button>
          </div>

          <!-- Row 1: Lade/ Speichere Projekt -->
          <div class="grid-2">
            <label class="btn primary" for="loadProjectFile">
              <span class="icon"><svg viewBox="0 0 24 24" fill="none"><path d="M12 3v12m0 0l-4-4m4 4l4-4M3 21h18" stroke="#93c5fd" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"/></svg></span>
              Lade Projekt
            </label>
            <button id="saveProject" class="btn">
              <span class="icon"><svg viewBox="0 0 24 24" fill="none"><path d="M17 3H7a2 2 0 0 0-2 2v14l7-3 7 3V5a2 2 0 0 0-2-2z" stroke="#93c5fd" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/></svg></span>
              Speichere Projekt
            </button>
            <input id="loadProjectFile" type="file" accept="application/json,.json" class="file" />
          </div>

          <!-- Row 2: Öffne Datei / Zurücksetzen -->
          <div class="grid-2">
            <label class="btn" for="file">
              <span class="icon"><svg viewBox="0 0 24 24" fill="none"><path d="M12 16V4m0 0l3 3m-3-3L9 7M4 20h16" stroke="#a5b4fc" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/></svg></span>
              Öffne Datei
            </label>
            <button id="clearBtn" class="btn warn">
              <span class="icon"><svg viewBox="0 0 24 24" fill="none"><path d="M6 6l12 12M18 6L6 18" stroke="#fecaca" stroke-width="1.8" stroke-linecap="round"/></svg></span>
              Zurücksetzen
            </button>
            <input id="file" type="file" accept=".mp3,.wav,audio/*" class="file" />
          </div>

          <!-- Row 3: Dateiname / Taktart+BPM -->
          <div class="grid-2">
            <div>
              <div class="label">Dateiname</div>
              <div class="filename-chip"><span class="dot"></span><span id="fileInfo">–</span></div>
            </div>
            <div>
              <!-- Taktart-Dropdown -->
              <div class="label">Taktart</div>
              <select id="timeSig" class="field mono">
                <option value="4" selected>4/4</option>
                <option value="3">3/4</option>
              </select>

              <div class="label" style="margin-top:8px;">Tempo (BPM)</div>
              <input id="bpm" type="number" min="1" max="999" step="0.01" class="field mono" />
              <button id="tapBpm" class="btn" style="margin-top:8px;width:100%;" title="Tippe im Takt">Tap BPM</button>
            </div>
          </div>

          <!-- Waveform -->
          <div class="section-gap"></div>
          <canvas id="wave" height="240" aria-label="Wellenform"></canvas>
          <div style="text-align:center">
            <span class="under-time mono">Cursor: <span id="curLabel">0:00.000</span></span>
          </div>

          <!-- Marker setzen / entfernen -->
          <div class="v-gap"></div>
          <div class="grid-2">
            <button id="addMarker" class="btn ok">
              <span class="icon"><svg viewBox="0 0 24 24" fill="none"><path d="M12 5v14M5 12h14" stroke="#86efac" stroke-width="1.8" stroke-linecap="round"/></svg></span>
              Marker setzen
            </button>
            <button id="deleteMarker" class="btn warn">
              <span class="icon"><svg viewBox="0 0 24 24" fill="none"><path d="M6 6l12 12M18 6L6 18" stroke="#fecaca" stroke-width="1.8" stroke-linecap="round"/></svg></span>
              Marker entfernen
            </button>
          </div>

          <!-- Großer Play / Stop -->
          <div class="v-gap"></div>
          <div class="grid-2">
            <button id="playSel" class="btn big primary">
              <span class="icon play"><svg viewBox="0 0 24 24" fill="#93c5fd"><path d="M8 5v14l11-7z"/></svg></span>
              Abspielen
            </button>
            <button id="pauseBtn" class="btn big">
              <span class="icon stop"><svg viewBox="0 0 24 24" fill="#fca5a5"><rect x="6" y="6" width="12" height="12" rx="2"/></svg></span>
              Stop
            </button>
          </div>

          <!-- Reihenfolge-Schalter -->
          <div id="markerSeqControls" class="card" style="padding:10px; margin-bottom:10px; display:flex; align-items:center; gap:10px;">
            <label class="btn toggle" style="cursor:pointer; display:flex; align-items:center; gap:10px;">
              <input id="playSeqToggle" type="checkbox" style="width:18px;height:18px; accent-color:#60a5fa; cursor:pointer;" />
              <span>Custom Arrangement</span>
            </label>
            <div id="seqInfo" class="label" style="margin:0; opacity:.9;">Sortiere Marker per Drag and Drop. Bei Aktivierung wird diese Reihenfolge gespielt.</div>
          </div>

          <!-- Marker-Liste -->
          <div id="markerList" class="markerList"></div>

          <input id="loadAudioForProject" type="file" accept=".mp3,.wav,audio/*" class="file" />
        </div>
      </section>

      <!-- Rechte Seite: Texteditor gekoppelt an 2-Takt-Gruppen -->
      <section class="page right">
        <h1>Tommy's Notebook</h1>
        <div class="card note-wrap">
          <div class="note-tools">
            <button id="toggleAutoscroll" class="btn toggle" title="Automatisches Scrollen ein/aus">Autoscroll: An</button>
            <button id="importMarkersBtn" class="btn toggle" title="Marker in Editor übernehmen">Marker übernehmen</button>
          </div>

          <div class="lyricsList" id="lyricsList"></div>
          <div class="note-export">
            <button id="exportTxtBtn" class="btn">Export</button>
          </div>
        </div>
      </section>
    </div>
  </div>

  <!-- Flip-Logik -->
  <script>
    const book = document.getElementById('book');
    const toRight = document.getElementById('toRight');
    const toLeft  = document.getElementById('toLeft');
    function showRight(){ book.classList.add('flipped'); toRight.style.display='none'; toLeft.style.display='flex'; }
    function showLeft(){ book.classList.remove('flipped'); toLeft.style.display='none'; toRight.style.display='flex'; }
    toRight.addEventListener('click', showRight);
    toLeft .addEventListener('click', showLeft);
    window.addEventListener('keydown', (e)=>{ if(e.key==='Escape' && book.classList.contains('flipped')) showLeft(); });
  </script>

  <!-- Hauptskript -->
  <script>
    // --- DOM ---
    const fileInput = document.getElementById('file');
    const clearBtn = document.getElementById('clearBtn');
    const saveProjectBtn = document.getElementById('saveProject');
    const loadProjectInput = document.getElementById('loadProjectFile');
    const loadAudioForProject = document.getElementById('loadAudioForProject');
    const fileInfo = document.getElementById('fileInfo');

    const bpmInput = document.getElementById('bpm');
    const timeSigSel = document.getElementById('timeSig');
    const playSel = document.getElementById('playSel');
    const pauseBtn = document.getElementById('pauseBtn');

    const addMarkerBtn = document.getElementById('addMarker');
    const deleteMarkerBtn = document.getElementById('deleteMarker');

    const markerListEl = document.getElementById('markerList');

    // Reihenfolge-Playback DOM
    const playSeqToggle = document.getElementById('playSeqToggle');
    const seqInfo = document.getElementById('seqInfo');

    const wave = document.getElementById('wave');
    const curLabel = document.getElementById('curLabel');
    const ctx = wave.getContext('2d');

    // --- Hinweisleiste ---
    const notice = document.getElementById('notice');
    const noticeText = document.getElementById('noticeText');
    const noticeBtn = document.getElementById('noticeBtn');

    // --- Rechter Editor DOM ---
    const lyricsListEl = document.getElementById('lyricsList');
    const importMarkersBtn = document.getElementById('importMarkersBtn');
    const exportTxtBtn = document.getElementById('exportTxtBtn');
    const toggleAutoscrollBtn = document.getElementById('toggleAutoscroll');

    // --- Tap-to-BPM ---
    const tapBpmBtn = document.getElementById('tapBpm');
    if (tapBpmBtn) {
      const tapTimes = [];
      let lastTapMs = 0;
      tapBpmBtn.addEventListener('click', ()=>{
        const now = performance.now();
        if (now - lastTapMs > 2000) tapTimes.length = 0;
        tapTimes.push(now); lastTapMs = now;
        if (tapTimes.length >= 2) {
          const diffs = tapTimes.slice(-9).map((t,i,arr)=> i>0 ? (t - arr[i-1]) / 1000 : null).filter(v=> v !== null);
          if (diffs.length > 0) {
            const avg = diffs.reduce((a,b)=>a+b,0) / diffs.length;
            let est = 60 / avg; est = Math.max(1, Math.min(999, est));
            bpmInput.value = String(Math.round(est));
            try {
              minView = Math.max(0.25, gridStep()/4);
              rebuildLyrics({ preserve: true });
              draw();
              if (usingEngine) resumeWithUpdatedLoopPreservingPhase();
            } catch(_){}
          }
        }
      });
    }

    // --- State ---
    let objectUrl = null, relativeAudioName = null;
    let duration = 0, audioBuffer = null, sampleRate = 44100;
    // Reihenfolge-Playback State
    let playSeqOrder = false;
    let seqCurrentStartId = null;

    let loadedFileMeta = null;

    // variable Taktlänge
    let beatsPerBar = 4; // 4/4 default
    const EPS = 1e-6;

    // Rahmen
    const FRAME_PAD = 52;

    // Marker
    let markers = [];
    let cursorTime = 0;

    // Lyrics/Textzeilen (eine Zeile = 2 Takte)
    let lyrics = [];
    let markerHeaders = [];
    let perSegmentLineNumbering = false;
    let autoScrollEnabled = true;
    let lastActiveLine = -1;

    // Viewport
    let viewStart = 0;
    let viewDur = 0;
    let minView = 0.25;

    // Gesten
    const activePointers = new Map();
    let draggingCursor=false, draggingPan=false;
    let panStartX=0, panStartViewStart=0;
    let pinchStartDist = 0, pinchCenterTime = 0, pinchStartViewDur = 0;

    // Tap-to-seek & Marker-Label Interaktion
    let tapCandidate = false; let downX = 0, downY = 0;
    let tapOnMarkerLabel = false;
    const renderHit = new Map();
    let tapTimer=null, lastTapId=null, longTimer=null, draggingMarkerId=null;

    // WebAudio
    let ac=null, masterGain=null, engineSource=null, engineGain=null, usingEngine=false;
    let rafId=0, engineStartCtxTime=0, engineStartOffset=0;

    // --- Utils ---
    function uid(){ return Math.random().toString(36).slice(2,9); }
    function clamp(v,min,max){ return Math.min(max,Math.max(min,v)); }
    function formatTime(t){
      if(!isFinite(t)) t=0;
      const h = Math.floor(t/3600);
      const m = Math.floor((t%3600)/60);
      const s = Math.floor(t%60);
      const ms = Math.round((t%1)*1000);
      if(h>0) return `${h}:${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}.${ms.toString().padStart(3,'0')}`;
      return `${m}:${s.toString().padStart(2,'0')}.${ms.toString().padStart(3,'0')}`;
    }
    function shortTimeLabel(t){
      const h = Math.floor(t/3600), m = Math.floor((t%3600)/60), s = Math.floor(t%60);
      if(h>0) return `${h}:${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`;
      if(m>0) return `${m}:${s.toString().padStart(2,'0')}`;
      return `${s}s`;
    }
    function bpm(){ const v=parseFloat(bpmInput.value); return isFinite(v)&&v>0?v:120; }

    // Taktlänge dynamisch + 1-Takt Raster
    function barLen(){ return (60 / bpm()) * beatsPerBar; }
    function gridStep(){ return barLen(); }

    function snapToGrid(t){ const step=gridStep(); return Math.round(t/step)*step; }
    function viewEnd(){ return viewStart + viewDur; }
    function setView(start, dur){
      if(duration<=0){ viewStart=0; viewDur=0; return; }
      const minDur = Math.min(Math.max(minView, gridStep()/4), duration);
      const newDur = clamp(dur, minDur, duration);
      const maxStart = Math.max(0, duration - newDur);
      viewStart = clamp(start, 0, maxStart);
      viewDur = newDur;
    }
    function timeToX(t, w){ return ((t - viewStart) / viewDur) * w; }
    function xToTime(x, w){ return viewStart + (x / w) * viewDur; }

    // Drag-Liste Helpers
    function ensureListOrder(){
      if(!Array.isArray(markers)) return;
      let changed = false;
      for(let i=0;i<markers.length;i++){
        if(!Number.isFinite(markers[i].listOrder)){ markers[i].listOrder = i; changed = true; }
      }
      if(changed) markers.sort((a,b)=> (a.listOrder ?? 0) - (b.listOrder ?? 0));
    }
    function reindexListOrder(){ markers.forEach((m,i)=> m.listOrder = i); }
    function reorderById(dragId, newIndex){
      const ordered = markers.slice().sort((a,b)=> (a.listOrder ?? 0) - (b.listOrder ?? 0));
      const from = ordered.findIndex(m=>m.id===dragId);
      if(from<0) return;
      if(ordered[from].pin !== 'start' && ordered[from].pin !== 'end'){
        const [item] = ordered.splice(from,1);
        const sIdx = ordered.findIndex(m=>m.pin==='start');
        let eIdx = ordered.findIndex(m=>m.pin==='end');
        let target = Math.max(0, Math.min(newIndex, ordered.length));
        if(sIdx !== -1) target = Math.max(target, 1);
        eIdx = ordered.findIndex(m=>m.pin==='end');
        if(eIdx !== -1) target = Math.min(target, eIdx);
        ordered.splice(target, 0, item);
      }
      let idxS = ordered.findIndex(m=>m.pin==='start');
      if(idxS > 0){ const [s] = ordered.splice(idxS,1); ordered.unshift(s); }
      let idxE = ordered.findIndex(m=>m.pin==='end');
      if(idxE >= 0 && idxE !== ordered.length-1){ const [e] = ordered.splice(idxE,1); ordered.push(e); }
      ordered.forEach((m,i)=> m.listOrder = i);
      markers = ordered;
    }
    function insertMarkerAscending(newM){
      ensureListOrder();
      const ordered = markers.slice().sort((a,b)=> (a.listOrder ?? 0) - (b.listOrder ?? 0));
      const hasStart = ordered.some(m=>m.pin==='start');
      const hasEnd   = ordered.some(m=>m.pin==='end');
      const middle = ordered.filter(m=> m.pin!=='start' && m.pin!=='end');
      let ins = middle.findIndex(m=> newM.time <= m.time);
      if(ins < 0) ins = middle.length;
      middle.splice(ins, 0, newM);
      let rebuilt = [];
      if(hasStart){ const s = ordered.find(m=>m.pin==='start'); if(s) rebuilt.push(s); }
      rebuilt = rebuilt.concat(middle);
      if(hasEnd){ const e = ordered.find(m=>m.pin==='end'); if(e) rebuilt.push(e); }
      if(!hasStart && !hasEnd){ rebuilt = ordered.concat([newM]).sort((a,b)=> a.time - b.time); }
      if(hasStart && !hasEnd){
        const rest = ordered.filter(m=> m.pin!=='start');
        const tmp = rest.concat([newM]).sort((a,b)=> a.time - b.time);
        rebuilt = [ordered.find(m=>m.pin==='start')].concat(tmp);
      }
      if(!hasStart && hasEnd){
        const rest = ordered.filter(m=> m.pin!=='end');
        const tmp = rest.concat([newM]).sort((a,b)=> a.time - b.time);
        rebuilt = tmp.concat([ordered.find(m=>m.pin==='end')]);
      }
      rebuilt.forEach((m,i)=> m.listOrder = i);
      markers = rebuilt;
    }

    function getActiveMarkersSorted(){ return markers.filter(m=>m.active).sort((a,b)=>a.time-b.time).slice(0,2); }
    function ensureMaxTwoActive(toggled){
      const act = markers.filter(m=>m.active);
      if(act.length <= 2) return;
      const others = act.filter(m=>m.id!==toggled.id);
      let closest = others[0], best = Math.abs(others[0].time - toggled.time);
      for(let i=1;i<others.length;i++){
        const d = Math.abs(others[i].time - toggled.time);
        if(d < best){ best = d; closest = others[i]; }
      }
      closest.active = false;
    }

    // === Quick Loop: State & Helpers ===
    const quickLoop = { active:false, a:null, b:null };
    let qlLongTimer = null;
    const QL_LONG_MS = 350;
    const QL_MOVE_TOL = 8;

    function lineStartTimeFromIndex(lineIdx0){
      const bl = barLen();         // 1 Takt
      return Math.max(0, lineIdx0 * 2 * bl); // 2 Takte pro Zeile
    }
    function applyQuickLoopClasses(){
      const rows = lyricsListEl.querySelectorAll('.lyricsRow');
      rows.forEach((row, i)=>{
        const idxEl = row.querySelector('.idx');
        if(!idxEl) return;
        idxEl.classList.remove('ql-active');
        if(quickLoop.active){ if(i === quickLoop.a || i === quickLoop.b) idxEl.classList.add('ql-active'); }
      });
    }
    function clearQuickLoop(){
      quickLoop.active = false; quickLoop.a = null; quickLoop.b = null;
      applyQuickLoopClasses(); draw();
      if(usingEngine) resumeWithUpdatedLoopPreservingPhase();
    }
    function setQuickLoopFromLines(i0, i1){
      const a = Math.min(i0, i1), b = Math.max(i0, i1);
      quickLoop.active = true; quickLoop.a = a; quickLoop.b = b;
      applyQuickLoopClasses(); draw();
      if(usingEngine) resumeWithUpdatedLoopPreservingPhase();
    }

    function getLoopRegion(){
      // 1) Quick-Loop
      if(quickLoop.active && quickLoop.a !== null && quickLoop.b !== null){
        const s = lineStartTimeFromIndex(Math.min(quickLoop.a, quickLoop.b));
        const e = lineStartTimeFromIndex(Math.max(quickLoop.a, quickLoop.b)) + 2 * barLen(); // explizit 2 Takte
        return { s: clamp(s,0,duration), e: clamp(e,0,duration), mode:'quick' };
      }
      // 2) Marker
      const act = getActiveMarkersSorted();
      if(act.length===2){
        const s=Math.min(act[0].time,act[1].time), e=Math.max(act[0].time,act[1].time);
        return { s, e, mode:'markers' };
      }
      return { s:0, e:duration, mode:'full' };
    }

    function getPlayheadTime(){
      if(usingEngine && ac && engineSource){
        const { s, e, mode } = getLoopRegion();
        const tCtx = ac.currentTime - engineStartCtxTime;
        let t = engineStartOffset + tCtx;
        if (mode === 'markers' || mode === 'quick') {
          if (t >= e) { const L = Math.max(1e-9, e - s); t = s + ((((t - e) % L) + L) % L); }
        }
        return clamp(t, 0, duration);
      }
      return cursorTime;
    }

    function startPump(){
      if(rafId) cancelAnimationFrame(rafId);
      const pump = () => {
        const t = getPlayheadTime();
        cursorTime = t;
        curLabel.textContent = formatTime(t);
        draw();
        updateLyricsHighlight(t);
        rafId = requestAnimationFrame(pump);
      };
      rafId = requestAnimationFrame(pump);
    }
    function stopPump(){ if(rafId){ cancelAnimationFrame(rafId); rafId=0; } }

    function ensureAC(){ if(!ac){ const AC=window.AudioContext||window.webkitAudioContext; ac=new AC(); masterGain=ac.createGain(); masterGain.gain.value=1; masterGain.connect(ac.destination); } }
    async function ensureACResumed(){ ensureAC(); try{ await ac.resume(); }catch(_){ } }

    function stopEngine(){
      const wasPlaying = usingEngine && ac && engineSource;
      let snapped = null;
      if (wasPlaying) {
        const tNow = getPlayheadTime();
        snapped = clamp(snapToGrid(tNow), 0, duration || 0);
      }
      if (engineSource){ try{ engineSource.stop(); }catch(_){} try{ engineSource.disconnect(); }catch{}_ ; engineSource = null; }
      if (engineGain){ try{ engineGain.disconnect(); }catch{}_ ; engineGain = null; }
      usingEngine = false;
      stopPump();
      if (wasPlaying && snapped !== null) {
        cursorTime = snapped;
        curLabel.textContent = formatTime(cursorTime);
      }
      draw();
      updateLyricsHighlight(cursorTime);
    }

    function startEngineAt(offset){
      if(!audioBuffer) return alert('Bitte zuerst eine Audiodatei laden.');
      ensureAC();
      if(engineSource){ try{engineSource.stop();}catch(_){} try{engineSource.disconnect();}catch(_){} }
      const loop = getLoopRegion();
      const src = ac.createBufferSource();
      src.buffer = audioBuffer;
      src.loop = (loop.mode === 'markers' || loop.mode === 'quick');
      src.loopStart = loop.s;
      src.loopEnd = (loop.e > 0 ? loop.e : duration);

      const g = ac.createGain();
      g.gain.setValueAtTime(0, ac.currentTime);
      g.gain.linearRampToValueAtTime(1, ac.currentTime + 0.01);
      src.connect(g); g.connect(masterGain);

      engineSource = src;
      engineGain = g;

      const startAt = clamp(offset, 0, duration);
      engineStartCtxTime = ac.currentTime;
      engineStartOffset  = startAt;
      try { src.start(ac.currentTime, startAt); } catch(e){ console.warn(e); return; }
      usingEngine = true;
      startPump();
      updateLyricsHighlight(startAt);
    }

    function restartEngineAt(t){ if(!audioBuffer) return; startEngineAt(t); }
    function resumeWithUpdatedLoopPreservingPhase(){
      if(!usingEngine){ draw(); updateLyricsHighlight(cursorTime); return; }
      const prevT = getPlayheadTime();
      const {s,e} = getLoopRegion();
      let target = prevT;
      if(prevT < s || prevT >= e) target = s;
      startEngineAt(target);
    }

    // ---------- Texteditor ----------
    function computeCounts(){
      if(!duration || !isFinite(duration)) return { bars:0, lines:0 };
      const bl = barLen();
      if(!isFinite(bl) || bl<=0) return { bars:0, lines:0 };
      const bars = Math.floor((duration + EPS) / bl);
      const lines = Math.floor(bars / 2); // 2 Takte pro Zeile
      return { bars, lines };
    }

    function renderLyricsList(){
      const { bars, lines } = computeCounts();
      lyricsListEl.innerHTML = '';
      const headersByLine = new Map();
      markerHeaders.forEach(h=>{
        if(h.lineIdx>=1 && h.lineIdx<=lines){
          if(!headersByLine.has(h.lineIdx)) headersByLine.set(h.lineIdx, []);
          headersByLine.get(h.lineIdx).push(h);
        }
      });
      let segStarts = [];
      if (perSegmentLineNumbering && Array.isArray(markerHeaders) && markerHeaders.length > 0) {
        const s = new Set();
        markerHeaders.forEach(h => { if (Number.isFinite(h.lineIdx)) s.add(Math.max(1, Math.floor(h.lineIdx))); });
        segStarts = Array.from(s).sort((a,b)=>a-b);
        if (segStarts[0] !== 1) segStarts.unshift(1);
      }
      let segPtr = 0;

      for(let i=0;i<lines;i++){
        const headers = headersByLine.get(i+1) || [];
        headers.sort((a,b)=> a.bar - b.bar);
        headers.forEach(h=>{
          const seg = document.createElement('div');
          seg.className = 'segmentHeader';
          seg.textContent = `${h.label}`;
          lyricsListEl.appendChild(seg);
        });

        const row = document.createElement('div'); row.className = 'lyricsRow'; row.dataset.idx = i;
        const idx = document.createElement('div'); idx.className = 'idx'; let __displayIdx = i + 1;
        if (perSegmentLineNumbering && segStarts.length) {
          while ((segPtr + 1) < segStarts.length && (i + 1) >= segStarts[segPtr + 1]) segPtr++;
          __displayIdx = (i + 1) - segStarts[segPtr] + 1;
        }
        idx.textContent = String(__displayIdx);

        // Quick-Loop Gesten
        let __downX=0, __downY=0, pressed=false, longFired=false;
        idx.addEventListener('pointerdown', (ev)=>{
          idx.setPointerCapture?.(ev.pointerId);
          pressed=true; longFired=false; __downX=ev.clientX; __downY=ev.clientY;
          qlLongTimer = setTimeout(()=>{
            longFired = true;
            if(!quickLoop.active){
              quickLoop.active = true; quickLoop.a = i; quickLoop.b = null;
            }else if(quickLoop.active && quickLoop.b===null){
              if(i === quickLoop.a){ clearQuickLoop(); }
              else { setQuickLoopFromLines(quickLoop.a, i); }
            }else{
              if(i === quickLoop.a || i === quickLoop.b){ clearQuickLoop(); }
              else { quickLoop.active = true; quickLoop.a = i; quickLoop.b = null; applyQuickLoopClasses(); draw(); if(usingEngine) resumeWithUpdatedLoopPreservingPhase(); }
            }
            applyQuickLoopClasses();
          }, 350);
        });
        idx.addEventListener('pointermove', (ev)=>{ if(!pressed) return; if(Math.hypot(ev.clientX-__downX, ev.clientY-__downY) > 8){ clearTimeout(qlLongTimer); qlLongTimer=null; } });
        idx.addEventListener('pointerup', (ev)=>{
          if(!pressed) return; pressed=false; clearTimeout(qlLongTimer); qlLongTimer=null;
          if(!longFired){ const t = lineStartTimeFromIndex(i); setCursor(t, true); if(usingEngine) restartEngineAt(cursorTime); draw(); }
          idx.releasePointerCapture?.(ev.pointerId);
        });
        idx.addEventListener('pointercancel', ()=>{ pressed=false; clearTimeout(qlLongTimer); qlLongTimer=null; });

        const line = document.createElement('div'); line.className = 'line'; line.contentEditable = 'true'; line.spellcheck = false;
        line.textContent = lyrics[i] || '';
        line.addEventListener('input', ()=>{ lyrics[i] = line.textContent; });
        row.appendChild(idx); row.appendChild(line);
        lyricsListEl.appendChild(row);
      }
      applyQuickLoopClasses();
    }
    function rebuildLyrics({ preserve=true }={}){ const { lines } = computeCounts(); if(preserve){ lyrics.length = lines; } else { lyrics = new Array(lines).fill(''); } renderLyricsList(); }

    // Default Start/End Marker
    function ensureDefaultStartEndMarkers() {
      if (!Number.isFinite(duration) || duration <= 0) return;
      if (Array.isArray(markers) && markers.length === 0) {
        const startM = { id: uid(), time: 0,        label: 'Start', active: true,  pin: 'start', listOrder: 0 };
        const endM   = { id: uid(), time: duration, label: 'Ende',  active: true,  pin: 'end', listOrder: 1 };
        markers.push(startM, endM);
        reindexListOrder();
        renderMarkerList(); draw();
        if (usingEngine) resumeWithUpdatedLoopPreservingPhase();
      }
    }

    function setActiveLine(idx){
      const rows = lyricsListEl.querySelectorAll('.lyricsRow');
      if(rows.length===0){ lastActiveLine = -1; return; }
      idx = Number.isFinite(idx) ? idx : -1;
      idx = (idx>=0 && idx<rows.length) ? idx : -1;
      if(lastActiveLine>=0 && rows[lastActiveLine]) rows[lastActiveLine].classList.remove('active');
      if(idx>=0 && rows[idx]) rows[idx].classList.add('active');
      lastActiveLine = idx;
      if(idx>=0 && book.classList.contains('flipped') && autoScrollEnabled){ rows[idx].scrollIntoView({ block:'center', behavior:'smooth' }); }
    }
    function updateLyricsHighlight(t){
      const { lines } = computeCounts();
      if(lines<=0){ setActiveLine(-1); return; }
      const bl = barLen();
      if(!isFinite(bl) || bl<=0){ setActiveLine(-1); return; }
      const barIdx = Math.floor((t + EPS) / bl);
      const lineIdx = Math.floor(barIdx / 2);
      if(lineIdx !== lastActiveLine) setActiveLine(lineIdx);
    }

    // Skala
    function pickTimeStep(viewSpan){
      const steps=[0.1,0.2,0.5,1,2,5,10,15,30,60,120,300,600,900,1800,3600,7200];
      for(const st of steps){ if(viewSpan/st<=10) return st; }
      return steps.at(-1);
    }

    function draw(){
      const dpr = window.devicePixelRatio||1;
      const cssW = wave.clientWidth || 340, cssH = 240;
      wave.width = Math.floor(cssW*dpr); wave.height = Math.floor(cssH*dpr);
      const ctx = wave.getContext('2d');
      ctx.setTransform(dpr,0,0,dpr,0,0);
      ctx.clearRect(0,0,cssW,cssH);
      renderHit.clear();

      const LABEL_MARGIN = 12, LABEL_H = 16;
      const waveTop = FRAME_PAD, waveBottom = cssH - FRAME_PAD;
      const waveHeight = waveBottom - waveTop;
      const mid = waveTop + waveHeight/2;

      ctx.fillStyle='#0c1423'; ctx.fillRect(0,0,cssW,cssH);
      ctx.strokeStyle='#0b1220'; ctx.strokeRect(0.5,0.5,cssW-1,cssH-1);

      // Quick-Loop-Füllung
      try{
        const lr = getLoopRegion();
        if(lr.mode === 'quick'){
          const left  = Math.max(0, Math.min(cssW, timeToX(lr.s, cssW)));
          const right = Math.max(0, Math.min(cssW, timeToX(lr.e, cssW)));
          if(right > left){ ctx.fillStyle='rgba(239,68,68,0.22)'; ctx.fillRect(left, waveTop, right-left, waveBottom - waveTop); }
        }
      }catch(e){}

      // Waveform
      if(audioBuffer){
        const ch = audioBuffer.getChannelData(0);
        sampleRate = audioBuffer.sampleRate || sampleRate;
        const startSample = Math.floor(Math.max(0, viewStart) * sampleRate);
        const endSample = Math.min(ch.length, Math.ceil(viewEnd() * sampleRate));
        const samplesVisible = Math.max(1, endSample - startSample);
        const sppx = Math.max(1, Math.floor(samplesVisible / cssW));
        ctx.strokeStyle = '#64748b';
        ctx.beginPath();
        for(let x=0;x<cssW;x++){
          const s0 = startSample + x * sppx;
          let min = 1, max = -1;
          for(let i=0;i<sppx && (s0+i)<endSample;i++){
            const v = ch[s0+i]||0; if(v<min) min=v; if(v>max) max=v;
          }
          ctx.moveTo(x, mid + min*(waveHeight/2-10));
          ctx.lineTo(x, mid + max*(waveHeight/2-10));
        }
        ctx.stroke();
      }

      // Zeitachse (unten)
      if(duration>0 && viewDur>0){
        const step=pickTimeStep(viewDur);
        const minor=step/5;
        const startMajor = Math.ceil(viewStart/step)*step;
        const startMinor = Math.ceil(viewStart/minor)*minor;

        ctx.strokeStyle='rgba(255,255,255,0.10)';
        for(let t=startMinor; t<=viewEnd()+EPS; t+=minor){
          if(Math.abs((t/step) - Math.round(t/step)) < 1e-6) continue;
          const x = timeToX(t, cssW);
          ctx.beginPath(); ctx.moveTo(x, waveBottom-8); ctx.lineTo(x, waveBottom-3); ctx.stroke();
        }

        ctx.strokeStyle='rgba(255,255,255,0.20)';
        ctx.fillStyle='rgba(203,213,225,0.95)';
        ctx.font='11px ui-monospace, SFMono-Regular, Menlo, monospace';
        for(let t=startMajor; t<=viewEnd()+EPS; t+=step){
          const x = timeToX(t, cssW);
          ctx.beginPath(); ctx.moveTo(x, waveBottom-14); ctx.lineTo(x, waveBottom-3); ctx.stroke();
          const lbl = shortTimeLabel(t);
          const w = ctx.measureText(lbl).width;
          const tx = Math.min(Math.max(x - w/2, 2), cssW - w - 2);
          ctx.fillText(lbl, tx, waveBottom - 16);
        }
      }

      // Raster (1-Takt-Linien)
      const stepGrid = gridStep();
      if(duration>0 && stepGrid>0){
        ctx.strokeStyle='rgba(96,165,250,0.25)';
        const t0 = Math.ceil((viewStart - EPS) / stepGrid) * stepGrid;
        for(let t=t0; t<=viewEnd()+EPS; t+=stepGrid){
          const x = timeToX(t, cssW);
          ctx.beginPath(); ctx.moveTo(x, waveTop); ctx.lineTo(x, waveBottom); ctx.stroke();
        }
      }

      // Marker-Loop-Füllung
      const act = getActiveMarkersSorted();
      if(act.length===2){
        const s=Math.min(act[0].time,act[1].time), e=Math.max(act[0].time,act[1].time);
        const left = Math.max(0, Math.min(cssW, timeToX(s, cssW)));
        const right = Math.max(0, Math.min(cssW, timeToX(e, cssW)));
        if(right>left){ ctx.fillStyle='rgba(37,99,235,0.18)'; ctx.fillRect(left, waveTop, right-left, waveBottom - waveTop); }
      }

      // Marker + Labels
      if(markers.length>0 && duration>0){
        ctx.font='11px ui-monospace, SFMono-Regular, Menlo, monospace';
        const sorted=markers.slice().sort((a,b)=>a.time-b.time);
        const visible=sorted.filter(m=>m.time>=viewStart-EPS && m.time<=viewEnd()+EPS);
        visible.forEach(m=>{
          const idx=sorted.findIndex(mm=>mm.id===m.id);
          const labelTop=(idx%2===0);
          const x=timeToX(m.time, cssW);
          const color = m.active ? 'rgba(239,68,68,0.95)' : 'rgba(96,165,250,0.95)';
          ctx.strokeStyle=color; ctx.beginPath(); ctx.moveTo(x, waveTop); ctx.lineTo(x, waveBottom); ctx.stroke();

          const txt=(m.label||'').slice(0,80);
          const pad=3, h=16, w=ctx.measureText(txt).width+pad*2;
          const lx=Math.min(Math.max(x-w/2,2), cssW-w-2);
          const ly=labelTop?12:(cssH-12-16);
          ctx.fillStyle='rgba(2,6,23,0.9)'; ctx.fillRect(lx,ly,w,h);
          ctx.strokeStyle=color; ctx.strokeRect(lx,ly,w,h);
          ctx.fillStyle='#e2e8f0'; ctx.fillText(txt, lx+pad, ly+12);
          ctx.strokeStyle=color; ctx.beginPath();
          if(labelTop){ ctx.moveTo(x, ly+h); ctx.lineTo(x, waveTop); } else { ctx.moveTo(x, ly); ctx.lineTo(x, waveBottom); }
          ctx.stroke();
          renderHit.set(m.id, { x, labelRect:{x:lx,y:ly,w,h} });
        });
      }

      // Cursor
      const cx = timeToX(cursorTime, cssW);
      if(cx>=0 && cx<=cssW){
        ctx.fillStyle='rgba(255,255,255,0.7)';
        ctx.fillRect(cx, waveTop, 2, waveBottom - waveTop);
        const handleY = waveTop - 12;
        ctx.beginPath(); ctx.arc(cx, handleY, 7, 0, Math.PI*2);
        ctx.fillStyle='#e2e8f0'; ctx.fill();
        ctx.beginPath(); ctx.moveTo(cx, handleY+6); ctx.lineTo(cx-6, handleY+12); ctx.lineTo(cx+6, handleY+12); ctx.closePath();
        ctx.fillStyle = '#e2e8f0'; ctx.fill();
      }
      updateLyricsHighlight(cursorTime);
    }

    // Cursor setzen
    function setCursor(t, snapIt=true){
      const step = gridStep();
      const target = snapIt ? Math.round(t/step)*step : t;
      cursorTime = clamp(target, 0, duration||0);
      curLabel.textContent = formatTime(cursorTime);
    }

    // Interaktion Canvas (Marker/Seek/Zoom/Pan) – unverändert
    function hitMarkerLabel(ev){
      const rect = wave.getBoundingClientRect();
      const px = ev.clientX - rect.left, py = ev.clientY - rect.top;
      for(const m of markers){
        const hit = renderHit.get(m.id); if(!hit) continue;
        const r = hit.labelRect;
        if(px>=r.x && px<=r.x+r.w && py>=r.y && py<=r.y+r.h) return m;
      }
      return null;
    }

    wave.addEventListener('pointerdown', (ev)=>{
      if(duration<=0) return;
      wave.setPointerCapture(ev.pointerId);
      activePointers.set(ev.pointerId,{x:ev.clientX,y:ev.clientY});
      downX = ev.clientX; downY = ev.clientY; tapCandidate = true;
      tapOnMarkerLabel = false;

      const rect=wave.getBoundingClientRect();
      const x=clamp(ev.clientX-rect.left,0,rect.width);
      const y=clamp(ev.clientY-rect.top,0,rect.height);
      const cx=timeToX(cursorTime, rect.width);
      const overHandle=(Math.abs(x-cx)<=14) && (y<=FRAME_PAD);

      if(activePointers.size===2){
        const pts=[...activePointers.values()];
        const dx=pts[1].x-pts[0].x, dy=pts[1].y-pts[0].y;
        pinchStartDist=Math.hypot(dx,dy); pinchStartViewDur=viewDur;
        const midX=(pts[0].x+pts[1].x)/2-rect.left; pinchCenterTime=xToTime(midX,rect.width);
        draggingCursor=false; draggingPan=false; clearTimeout(longTimer); longTimer=null; draggingMarkerId=null;
        return;
      }

      const m=hitMarkerLabel(ev);
      if(m){
        tapOnMarkerLabel = true;
        const startX=ev.clientX;
        longTimer=setTimeout(()=>{ draggingMarkerId=m.id; },300);
        const now=Date.now();
        const isDouble=(lastTapId===m.id && tapTimer && (now - tapTimer.time) < 300);
        if(isDouble){
          clearTimeout(tapTimer.handle); tapTimer=null; lastTapId=null;
          const name=prompt('Neuer Markername:', m.label||''); if(name!==null){ m.label=name; renderMarkerList(); draw(); }
        }else{
          tapTimer={ time:now, handle:setTimeout(()=>{
            m.active=!m.active; if(m.active) ensureMaxTwoActive(m);
            const act=markers.filter(x=>x.active).sort((a,b)=>a.time-b.time);
            if(act.length>2){ for(let i=2;i<act.length;i++) act[i].active=false; }
            renderMarkerList(); draw();
            if(usingEngine) resumeWithUpdatedLoopPreservingPhase();
            tapTimer=null; lastTapId=null;
          },320) }; lastTapId=m.id;
        }

        function onMove(e){
          if(draggingMarkerId===m.id){
            const rect=wave.getBoundingClientRect();
            const xx=clamp(e.clientX-rect.left,0,rect.width);
            const t=xToTime(xx,rect.width);
            m.time=clamp(snapToGrid(t),0,duration);
            markers.sort((a,b)=> (a.listOrder ?? 0) - (b.listOrder ?? 0));
            renderMarkerList(); draw();
            if(usingEngine && m.active) resumeWithUpdatedLoopPreservingPhase();
          }else{
            if(Math.abs(e.clientX-startX)>8){ clearTimeout(longTimer); longTimer=null; }
          }
        }
        function onUp(e){
          clearTimeout(longTimer); longTimer=null;
          if(draggingMarkerId===m.id){ draggingMarkerId=null; if(usingEngine) resumeWithUpdatedLoopPreservingPhase(); }
          wave.removeEventListener('pointermove', onMove);
          wave.removeEventListener('pointerup', onUp);
          wave.releasePointerCapture?.(e.pointerId);
        }
        wave.addEventListener('pointermove', onMove);
        wave.addEventListener('pointerup', onUp);
        return;
      }

      if(overHandle){ draggingCursor=true; draggingPan=false; clearTimeout(longTimer); longTimer=null; draggingMarkerId=null; return; }

      draggingPan=true; draggingCursor=false; clearTimeout(longTimer); longTimer=null; draggingMarkerId=null;
      panStartX=ev.clientX; panStartViewStart=viewStart;
    });

    wave.addEventListener('pointermove', (ev)=>{
      if(!activePointers.has(ev.pointerId)) return;
      activePointers.set(ev.pointerId,{x:ev.clientX,y:ev.clientY});
      const rect=wave.getBoundingClientRect();

      if(activePointers.size===1){
        if(draggingCursor){
          const x=clamp(ev.clientX-rect.left,0,rect.width);
          const t=xToTime(x,rect.width);
          setCursor(t,true);
          if(usingEngine) restartEngineAt(cursorTime);
          draw();
        } else if(draggingPan){
          const dx=ev.clientX-panStartX;
          const dt=(dx/rect.width)*viewDur;
          const newStart=clamp(panStartViewStart - dt, 0, Math.max(0, duration - viewDur));
          setView(newStart, viewDur);
          draw();
        }
      } else if(activePointers.size===2){
        const pts=[...activePointers.values()];
        const dx=pts[1].x-pts[0].x, dy=pts[1].y-pts[0].y;
        const dist=Math.hypot(dx,dy);
        const scale=(pinchStartDist>0)?(dist/pinchStartDist):1;
        let newDur=clamp(pinchStartViewDur/scale, Math.min(gridStep()/4, duration||1), duration||1);
        const midX=(pts[0].x+pts[1].x)/2-rect.left;
        const newStart=clamp(pinchCenterTime - (midX/rect.width)*newDur, 0, Math.max(0, (duration||0) - newDur));
        setView(newStart, newDur); draw();
      }
    });

    function endPointer(ev){
      activePointers.delete(ev.pointerId);
      if(activePointers.size===0){
        const rect = wave.getBoundingClientRect();
        const upX = clamp(ev.clientX - rect.left, 0, rect.width);
        const upY = clamp(ev.clientY - rect.top, 0, rect.height);
        const isInWaveform = (upY >= FRAME_PAD) && (upY <= rect.height - FRAME_PAD);
        const maySeek = tapCandidate && !draggingCursor && !draggingMarkerId && !tapOnMarkerLabel && !isInWaveform;
        if(maySeek){
          const t = xToTime(upX, rect.width);
          setCursor(t, true);
          if(usingEngine) restartEngineAt(cursorTime);
          draw();
        }
        tapCandidate = false;
      }
      if(activePointers.size===0){
        if(draggingCursor){ setCursor(cursorTime, true); }
        draggingCursor=false; draggingPan=false; draggingMarkerId=null; pinchStartDist=0;
        draw();
      }
      wave.releasePointerCapture?.(ev.pointerId);
    }
    wave.addEventListener('pointerup', endPointer);
    wave.addEventListener('pointercancel', endPointer);

    // Desktop Zoom per Ctrl+Wheel
    wave.addEventListener('wheel', (ev)=>{
      if(duration<=0) return;
      if(!ev.ctrlKey) return;
      ev.preventDefault();
      const rect=wave.getBoundingClientRect();
      const mouseX=clamp(ev.clientX-rect.left,0,rect.width);
      const anchorTime=xToTime(mouseX,rect.width);
      const factor=Math.exp(-ev.deltaY*0.0015);
      const targetDur=clamp(viewDur * (1/factor), Math.min(gridStep()/4, duration||1), duration||1);
      const newStart=clamp(anchorTime - targetDur*((mouseX/rect.width)), 0, Math.max(0, duration - targetDur));
      setView(newStart, targetDur); draw();
    }, { passive:false });

    // Projekt speichern/laden (+ Lyrics)
    function currentProject(){
      return {
        version:21,
        bpm: bpm(),
        beatsPerBar,   // wichtig für 3/4 vs 4/4
        cursorTime,
        markers: markers.map(m=>({ id:m.id, time:+m.time||0, label:m.label||'', active:!!m.active, listOrder: Number.isFinite(m.listOrder)? m.listOrder : 0 })),
        viewStart, viewDur,
        lyrics: Array.isArray(lyrics) ? lyrics.slice() : [],
        relativeAudio: relativeAudioName || (loadedFileMeta ? loadedFileMeta.name : null),
        file: loadedFileMeta || null,
        createdAt: new Date().toISOString(),
        playSeqOrder: !!playSeqOrder
      };
    }
    function downloadJson(obj,filename){
      const blob=new Blob([JSON.stringify(obj,null,2)],{type:'application/json'});
      const url=URL.createObjectURL(blob); const a=document.createElement('a');
      a.href=url; a.download=filename; document.body.appendChild(a); a.click(); a.remove();
      setTimeout(()=>URL.revokeObjectURL(url),1500);
    }

    saveProjectBtn?.addEventListener('click', ()=>{
      const defaultBase = (loadedFileMeta && loadedFileMeta.name ? loadedFileMeta.name.replace(/\.[^.]+$/, '') : 'projekt');
      let name = prompt('Dateiname für das Projekt (ohne oder mit .json):', `${defaultBase}_session`);
      if(name===null) return;
      name = name.trim() || 'projekt';
      if(!/\.json$/i.test(name)) name += '.json';
      downloadJson(currentProject(), name);
    });

    // --- Hinweisleiste Helfer ---
    function showNotice(msg, btnLabel, onClick){
      if(noticeText) noticeText.textContent = msg || '';
      if(noticeBtn){
        noticeBtn.textContent = btnLabel || 'OK';
        noticeBtn.onclick = onClick || null;
      }
      notice.hidden = false;
    }
    function hideNotice(){ notice.hidden = true; noticeBtn.onclick = null; }

    loadProjectInput?.addEventListener('change', async e=>{
      const f=e.target.files&&e.target.files[0]; if(!f) return;
      try{
        const txt=await f.text(); const json=JSON.parse(txt);

        playSeqOrder = !!json.playSeqOrder;
        if (playSeqToggle) playSeqToggle.checked = playSeqOrder;

        if (json.beatsPerBar === 3 || json.beatsPerBar === 4){
          beatsPerBar = json.beatsPerBar;
          if (timeSigSel) timeSigSel.value = String(beatsPerBar);
        } else { beatsPerBar = 4; if (timeSigSel) timeSigSel.value = '4'; }

        bpmInput.value = json.bpm || 120;
        cursorTime = +json.cursorTime || 0;
        markers = Array.isArray(json.markers) ? json.markers.map((m,i)=>({ id:m.id||uid(), time:+m.time||0, label:m.label||'', active:!!m.active, listOrder: Number.isFinite(m.listOrder)? +m.listOrder : i })) : [];
        markers.sort((a,b)=> (a.listOrder ?? 0) - (b.listOrder ?? 0));
        const vs = Number.isFinite(json.viewStart)? +json.viewStart : 0;
        const vd = Number.isFinite(json.viewDur) && json.viewDur>0 ? +json.viewDur : (duration||0);
        setView(vs, vd>0?vd:(duration||0));

        lyrics = Array.isArray(json.lyrics) ? json.lyrics.slice() : [];
        renderLyricsList();

        renderMarkerList(); draw();

        try{
          perSegmentLineNumbering = true;
          const blAuto = barLen();
          if(isFinite(blAuto) && blAuto > 0){
            const headersAuto = [];
            (markers||[])
              .filter(m=> (m.label||'').trim().length>0 && m.pin!=='start' && m.pin!=='end')
              .forEach(m=>{
                const barNumber = Math.floor((m.time + EPS) / blAuto) + 1;
                const lineIdx   = Math.floor((barNumber - 1) / 2) + 1; // 2 Takte/Zeile
                headersAuto.push({ lineIdx, label: m.label.trim(), bar: barNumber });
              });
            headersAuto.sort((a,b)=> a.lineIdx - b.lineIdx || a.bar - b.bar);
            markerHeaders = headersAuto;
            importMarkersBtn?.classList.add('active');
            if(importMarkersBtn) importMarkersBtn.textContent = 'Marker übernommen';
          }else{
            perSegmentLineNumbering = false;
            markerHeaders = [];
            importMarkersBtn?.classList.remove('active');
            if(importMarkersBtn) importMarkersBtn.textContent = 'Marker übernehmen';
          }
          renderLyricsList();
        }catch(e){}

        const expected = json.relativeAudio || (json.file && json.file.name) || '';

        // Statt alert + programmatic click: Hinweisleiste mit echtem Button
        showNotice(
          expected ? `Bitte die passende Audiodatei auswählen (erwartet: ${expected}).` : 'Bitte die passende Audiodatei auswählen.',
          'Audio wählen',
          ()=>{ try { loadAudioForProject.value=''; loadAudioForProject.click(); } catch(_){} }
        );

        // Raster/Ansichten aktualisieren
        minView = Math.max(0.25, gridStep()/4);
        draw();
      }catch(err){
        alert('Konnte Projekt nicht lesen: '+(err&&err.message?err.message:err));
      }
      e.target.value='';
    });

    loadAudioForProject?.addEventListener('change', async (e)=>{
      const file=e.target.files&&e.target.files[0]; if(!file) return;
      try{
        const arrayBuf=await file.arrayBuffer();
        const AC=window.AudioContext||window.webkitAudioContext; const tmp=new AC();
        audioBuffer=await tmp.decodeAudioData(arrayBuf);
        duration=audioBuffer.duration; sampleRate=audioBuffer.sampleRate; tmp.close();
        if(objectUrl) URL.revokeObjectURL(objectUrl);
        objectUrl=URL.createObjectURL(file);
        loadedFileMeta={ name:file.name, size:file.size, type:file.type||'', lastModified:file.lastModified||0 };
        relativeAudioName=file.name;
        fileInfo.textContent = file.name || '–';
        if(viewDur===0){ setView(0, duration); }
        hideNotice();
        draw();
        rebuildLyrics({ preserve:true });
        ensureDefaultStartEndMarkers();
      }catch(err){ alert('Konnte Audiodatei nicht laden: '+(err&&err.message?err.message:err)); }
    });

    // Einfacher Loader über "Öffne Datei"
    fileInput?.addEventListener('change', async e=>{
      const file=e.target.files&&e.target.files[0]; if(!file) return;
      try{
        const arrayBuf=await file.arrayBuffer();
        const AC=window.AudioContext||window.webkitAudioContext; const tmp=new AC();
        audioBuffer=await tmp.decodeAudioData(arrayBuf);
        duration=audioBuffer.duration; sampleRate=audioBuffer.sampleRate; tmp.close();
        if(objectUrl) URL.revokeObjectURL(objectUrl);
        objectUrl=URL.createObjectURL(file);
        loadedFileMeta={ name:file.name, size:file.size, type:file.type||'', lastModified:file.lastModified||0 };
        relativeAudioName=file.name;
        fileInfo.textContent = file.name || '–';
        if(viewDur===0){ setView(0, duration); }
        hideNotice();
        draw();
        rebuildLyrics({ preserve:true });
        ensureDefaultStartEndMarkers();
      }catch(err){ alert('Konnte Audiodatei nicht laden: '+(err&&err.message?err.message:err)); }
      e.target.value='';
    });

    // Marker-Liste (schlanke Version; Drag & Aktiv-Button)
    function renderMarkerList(){
      markerListEl.innerHTML = '';
      const list = markers.slice().sort((a,b)=> (a.listOrder ?? 0) - (b.listOrder ?? 0));
      list.forEach((m, idx)=>{
        const row = document.createElement('div'); row.className='markerRow'; row.draggable=true; row.dataset.id=m.id;

        const drag = document.createElement('div'); drag.className='dragHandle'; drag.innerHTML = '<svg viewBox="0 0 24 24" width="18" height="18" aria-hidden="true"><circle cx="8" cy="7" r="1.5" fill="#94a3b8"/><circle cx="8" cy="12" r="1.5" fill="#94a3b8"/><circle cx="8" cy="17" r="1.5" fill="#94a3b8"/><circle cx="14" cy="7" r="1.5" fill="#94a3b8"/><circle cx="14" cy="12" r="1.5" fill="#94a3b8"/><circle cx="14" cy="17" r="1.5" fill="#94a3b8"/></svg>';
        const title = document.createElement('input'); title.className='field'; title.value=m.label||''; title.placeholder='Marker'; title.addEventListener('input', ()=>{ m.label = title.value; });
        const time = document.createElement('div'); time.className='mono'; time.style.minWidth='90px'; time.textContent = formatTime(m.time);
        const tog  = document.createElement('button'); tog.className='btn'; tog.textContent = m.active ? 'Loop ✓' : 'Loop';
        tog.addEventListener('click', ()=>{
          m.active = !m.active; if(m.active) ensureMaxTwoActive(m);
          renderMarkerList(); draw();
          if(usingEngine) resumeWithUpdatedLoopPreservingPhase();
        });

        row.appendChild(drag); row.appendChild(title); row.appendChild(time); row.appendChild(tog);
        markerListEl.appendChild(row);

        // Drag & Drop
        row.addEventListener('dragstart', (e)=>{ e.dataTransfer.setData('text/plain', m.id); row.classList.add('dragging'); });
        row.addEventListener('dragend', ()=>{ row.classList.remove('dragging'); });
        row.addEventListener('dragover', (e)=>{ e.preventDefault(); row.classList.add('drop-target'); });
        row.addEventListener('dragleave', ()=>{ row.classList.remove('drop-target'); });
        row.addEventListener('drop', (e)=>{
          e.preventDefault(); row.classList.remove('drop-target');
          const dragId = e.dataTransfer.getData('text/plain');
          const children = Array.from(markerListEl.children);
          const newIndex = children.indexOf(row);
          reorderById(dragId, newIndex);
          renderMarkerList();
        });
      });
    }

    addMarkerBtn?.addEventListener('click', ()=>{
      const m = { id: uid(), time: snapToGrid(cursorTime), label: 'Marker', active:false, listOrder: (markers.length || 0) };
      insertMarkerAscending(m);
      renderMarkerList(); draw();
    });
    deleteMarkerBtn?.addEventListener('click', ()=>{
      const act = getActiveMarkersSorted();
      if(act.length){ markers = markers.filter(m=> m.id !== act[act.length-1].id); }
      else { markers.pop(); }
      reindexListOrder(); renderMarkerList(); draw();
    });

    playSel?.addEventListener('click', ()=>{ ensureACResumed().then(()=> startEngineAt(cursorTime)); });
    pauseBtn?.addEventListener('click', ()=> stopEngine());

    toggleAutoscrollBtn?.addEventListener('click', ()=>{
      autoScrollEnabled = !autoScrollEnabled;
      toggleAutoscrollBtn.classList.toggle('active', autoScrollEnabled);
      toggleAutoscrollBtn.textContent = 'Autoscroll: ' + (autoScrollEnabled ? 'An' : 'Aus');
    });

    importMarkersBtn?.addEventListener('click', ()=>{
      perSegmentLineNumbering = !perSegmentLineNumbering;
      importMarkersBtn.classList.toggle('active', perSegmentLineNumbering);
      importMarkersBtn.textContent = perSegmentLineNumbering ? 'Marker übernommen' : 'Marker übernehmen';
      const bl = barLen(); const headers = [];
      markers.filter(m=> (m.label||'').trim()).forEach(m=>{
        const barNumber = Math.floor((m.time + EPS) / bl) + 1;
        const lineIdx   = Math.floor((barNumber - 1) / 2) + 1;
        headers.push({ lineIdx, label: m.label.trim(), bar: barNumber });
      });
      headers.sort((a,b)=> a.lineIdx - b.lineIdx || a.bar - b.bar);
      markerHeaders = perSegmentLineNumbering ? headers : [];
      renderLyricsList();
    });

    exportTxtBtn?.addEventListener('click', ()=>{
      const { lines } = computeCounts();
      const parts = [];
      for (let i=0;i<lines;i++){
        const hs = markerHeaders.filter(h=>h.lineIdx===i+1).map(h=>h.label);
        hs.forEach(h=> parts.push(h));
        parts.push(lyrics[i]||'');
      }
      const base = (loadedFileMeta && loadedFileMeta.name ? loadedFileMeta.name.replace(/\.[^.]+$/, '') : 'lyrics');
      const blob = new Blob([parts.join('\n')], { type: 'text/plain;charset=utf-8' });
      const url  = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = `${base}_lyrics.txt`;
      document.body.appendChild(a); a.click(); a.remove();
      setTimeout(()=>URL.revokeObjectURL(url), 1500);
    });

    // Init
    window.addEventListener('resize', ()=>{ draw(); });
    ensureListOrder(); renderMarkerList(); draw();
    renderLyricsList();

    // Taktart-Handling
    function applyTimeSigFromUI(){
      const val = parseInt(timeSigSel?.value || '4', 10);
      beatsPerBar = (val===3 || val===4) ? val : 4;
      minView = Math.max(0.25, gridStep()/4);
      rebuildLyrics({ preserve: true });
      draw();
      if (usingEngine) resumeWithUpdatedLoopPreservingPhase();
    }
    timeSigSel?.addEventListener('change', applyTimeSigFromUI);
    bpmInput?.addEventListener('input', ()=>{
      minView = Math.max(0.25, gridStep()/4);
      rebuildLyrics({ preserve: true });
      draw();
      if (usingEngine) resumeWithUpdatedLoopPreservingPhase();
    });

    // Clear
    clearBtn?.addEventListener('click', ()=>{
      stopEngine();
      audioBuffer = null; duration = 0; sampleRate = 44100;
      markers = []; lyrics = []; markerHeaders = [];
      fileInfo.textContent = '–'; relativeAudioName = null; loadedFileMeta = null;
      viewStart = 0; viewDur = 0; cursorTime = 0;
      hideNotice();
      draw(); renderMarkerList(); renderLyricsList();
    });
  </script>
</body>
</html>